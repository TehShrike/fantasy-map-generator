{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b8385b018ebbbfa7f229","webpack:///./src/terrain/step2.js","webpack:///./src/terrain/step3.js","webpack:///./src/terrain/step1.js","webpack:///./src/terrain/step4.js","webpack:///./src/terrain/step6.js","webpack:///external \"d3-array\"","webpack:///./src/terrain/terrain.js","webpack:///./src/terrain/step5.js","webpack:///./src/terrain/step7.js","webpack:///external \"d3-voronoi\"","webpack:///external \"seedrandom\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;AChE+D;;AAE/D;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA;AAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1EoD;;AAE3B;;AAEzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;;;;;;;;;;;;AC/F6B;;AAE7B,uBAA8B;AAAA;AAAA;;AAE9B;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1Fa;AACM;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvFmB;AACO;;AAE1B;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrFA,+C;;;;;;;;;;;;;;;;;ACAA;AACsB;AACuB;AAC3B;AACF;AACe;;AAE/B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,sGAA+B,+EAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtDgE;AACG;AAC/C;AACF;;AAElB;AACA,sBAAsB,cAAc;AACpC;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChGmB;AACG;;AAEtB;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChBA,+C;;;;;;ACAA,gD","file":"main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3-array\"), require(\"d3-voronoi\"), require(\"seedrandom\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3-array\", \"d3-voronoi\", \"seedrandom\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3-array\"), require(\"d3-voronoi\"), require(\"seedrandom\")) : factory(root[\"d3-array\"], root[\"d3-voronoi\"], root[\"seedrandom\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_10__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b8385b018ebbbfa7f229","import {defaultExtent, generatePoints, improvePoints, makeMesh} from './step1';\n\nexport function zero(mesh) {\n    var z = [];\n    for (var i = 0; i < mesh.vxs.length; i++) {\n        z[i] = 0;\n    }\n    z.mesh = mesh;\n    return z;\n}\nexport function generateGoodMesh(n, extent) {\n    extent = extent || defaultExtent;\n    var pts = generateGoodPoints(n, extent);\n    return makeMesh(pts, extent);\n}\n\nexport function generateGoodPoints(n, extent) {\n    extent = extent || defaultExtent;\n    var pts = generatePoints(n, extent);\n    pts = pts.sort(function (a, b) {\n        return a[0] - b[0];\n    });\n    return improvePoints(pts, 1, extent);\n}\nexport function slope(mesh, direction) {\n    return mesh.map(function (x) {\n        return x[0] * direction[0] + x[1] * direction[1];\n    });\n}\nexport function runif(lo, hi) {\n    return lo + Math.random() * (hi - lo);\n}\nexport const rnorm = (function () {\n    var z2 = null;\n    function rnorm() {\n        if (z2 != null) {\n            var tmp = z2;\n            z2 = null;\n            return tmp;\n        }\n        var x1 = 0;\n        var x2 = 0;\n        var w = 2.0;\n        while (w >= 1) {\n            x1 = runif(-1, 1);\n            x2 = runif(-1, 1);\n            w = x1 * x1 + x2 * x2;\n        }\n        w = Math.sqrt(-2 * Math.log(w) / w);\n        z2 = x2 * w;\n        return x1 * w;\n    }\n    return rnorm;\n})();\nexport function randomVector(scale) {\n    return [scale * rnorm(), scale * rnorm()];\n}\nexport function add() {\n    var n = arguments[0].length;\n    var newvals = zero(arguments[0].mesh);\n    for (var i = 0; i < n; i++) {\n        for (var j = 0; j < arguments.length; j++) {\n            newvals[i] += arguments[j][i];\n        }\n    }\n    return newvals;\n}\n\nexport function isnearedge(mesh, i) {\n    var x = mesh.vxs[i][0];\n    var y = mesh.vxs[i][1];\n    var w = mesh.extent.width;\n    var h = mesh.extent.height;\n    return x < -0.45 * w || x > 0.45 * w || y < -0.45 * h || y > 0.45 * h;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/terrain/step2.js\n// module id = 0\n// module chunks = 0","import {ascending, min, max, quantile as d3quantile} from 'd3-array';\n\nimport {zero, isnearedge} from './step2';\n\nexport function cone(mesh, slope) {\n    return mesh.map(function (x) {\n        return Math.pow(x[0] * x[0] + x[1] * x[1], 0.5) * slope;\n    });\n}\nexport function mountains(mesh, n, r) {\n    r = r || 0.05;\n    var mounts = [];\n    for (var i = 0; i < n; i++) {\n        mounts.push([mesh.extent.width * (Math.random() - 0.5), mesh.extent.height * (Math.random() - 0.5)]);\n    }\n    var newvals = zero(mesh);\n    for (var i = 0; i < mesh.vxs.length; i++) {\n        var p = mesh.vxs[i];\n        for (var j = 0; j < n; j++) {\n            var m = mounts[j];\n            newvals[i] += Math.exp(-((p[0] - m[0]) * (p[0] - m[0]) + (p[1] - m[1]) * (p[1] - m[1])) / (r * r));\n        }\n    }\n    return newvals;\n}\nfunction map(h, f) {\n    var newh = h.map(f);\n    newh.mesh = h.mesh;\n    return newh;\n}\n\nfunction normalize(h) {\n    var lo = min(h);\n    var hi = max(h);\n    return map(h, function (x) {return (x - lo) / (hi - lo)});\n}\nexport function peaky(h) {\n    return map(normalize(h), Math.sqrt);\n}\nexport function neighbours(mesh, i) {\n    var onbs = mesh.adj[i];\n    var nbs = [];\n    for (var i = 0; i < onbs.length; i++) {\n        nbs.push(onbs[i]);\n    }\n    return nbs;\n}\nexport function fillSinks(h, epsilon) {\n    epsilon = epsilon || 1e-5;\n    var infinity = 999999;\n    var newh = zero(h.mesh);\n    for (var i = 0; i < h.length; i++) {\n        if (isnearedge(h.mesh, i)) {\n            newh[i] = h[i];\n        } else {\n            newh[i] = infinity;\n        }\n    }\n    while (true) {\n        var changed = false;\n        for (var i = 0; i < h.length; i++) {\n            if (newh[i] == h[i]) continue;\n            var nbs = neighbours(h.mesh, i);\n            for (var j = 0; j < nbs.length; j++) {\n                if (h[i] >= newh[nbs[j]] + epsilon) {\n                    newh[i] = h[i];\n                    changed = true;\n                    break;\n                }\n                var oh = newh[nbs[j]] + epsilon;\n                if ((newh[i] > oh) && (oh > h[i])) {\n                    newh[i] = oh;\n                    changed = true;\n                }\n            }\n        }\n        if (!changed) return newh;\n    }\n}\n\nfunction quantile(h, q) {\n    var sortedh = [];\n    for (var i = 0; i < h.length; i++) {\n        sortedh[i] = h[i];\n    }\n    sortedh.sort(ascending);\n    return d3quantile(sortedh, q);\n}\nexport function setSeaLevel(h, q) {\n    var newh = zero(h.mesh);\n    var delta = quantile(h, q);\n    for (var i = 0; i < h.length; i++) {\n        newh[i] = h[i] - delta;\n    }\n    return newh;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/terrain/step3.js\n// module id = 1\n// module chunks = 0","import {voronoi as d3voronoi} from 'd3-voronoi';\n\nexport const defaultExtent = {width: 1, height: 1};\n\n// code that exposes some functions goes here\nexport function generatePoints(n, extent) {\n    extent = extent || defaultExtent;\n    var pts = [];\n    for (var i = 0; i < n; i++) {\n        pts.push([(Math.random() - 0.5) * extent.width, (Math.random() - 0.5) * extent.height]);\n    }\n    return pts;\n}\nexport function makeMesh(pts, extent) {\n    extent = extent || defaultExtent;\n    var vor = voronoi(pts, extent);\n    var vxs = [];\n    var vxids = {};\n    var adj = [];\n    var edges = [];\n    var tris = [];\n    for (var i = 0; i < vor.edges.length; i++) {\n        var e = vor.edges[i];\n        if (e == undefined) continue;\n        var e0 = vxids[e[0]];\n        var e1 = vxids[e[1]];\n        if (e0 == undefined) {\n            e0 = vxs.length;\n            vxids[e[0]] = e0;\n            vxs.push(e[0]);\n        }\n        if (e1 == undefined) {\n            e1 = vxs.length;\n            vxids[e[1]] = e1;\n            vxs.push(e[1]);\n        }\n        adj[e0] = adj[e0] || [];\n        adj[e0].push(e1);\n        adj[e1] = adj[e1] || [];\n        adj[e1].push(e0);\n        edges.push([e0, e1, e.left, e.right]);\n        tris[e0] = tris[e0] || [];\n        if (!tris[e0].includes(e.left)) tris[e0].push(e.left);\n        if (e.right && !tris[e0].includes(e.right)) tris[e0].push(e.right);\n        tris[e1] = tris[e1] || [];\n        if (!tris[e1].includes(e.left)) tris[e1].push(e.left);\n        if (e.right && !tris[e1].includes(e.right)) tris[e1].push(e.right);\n    }\n    var mesh = {\n        pts: pts,\n        vor: vor,\n        vxs: vxs,\n        adj: adj,\n        tris: tris,\n        edges: edges,\n        extent: extent\n    };\n    mesh.map = function (f) {\n        var mapped = vxs.map(f);\n        mapped.mesh = mesh;\n        return mapped;\n    };\n    return mesh;\n}\n\nfunction voronoi(pts, extent) {\n    extent = extent || defaultExtent;\n    var w = extent.width/2;\n    var h = extent.height/2;\n    return d3voronoi().extent([[-w, -h], [w, h]])(pts);\n}\nfunction centroid(pts) {\n    var x = 0;\n    var y = 0;\n    for (var i = 0; i < pts.length; i++) {\n        x += pts[i][0];\n        y += pts[i][1];\n    }\n    return [x/pts.length, y/pts.length];\n}\n\nexport function improvePoints(pts, n, extent) {\n    n = n || 1;\n    extent = extent || defaultExtent;\n    for (var i = 0; i < n; i++) {\n        pts = voronoi(pts, extent)\n            .polygons(pts)\n            .map(centroid);\n    }\n    return pts;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/terrain/step1.js\n// module id = 2\n// module chunks = 0","import {zero} from './step2';\nimport {neighbours} from './step3';\n\nfunction isedge(mesh, i) {\n    return (mesh.adj[i].length < 3);\n}\nexport function downhill(h) {\n    if (h.downhill) return h.downhill;\n    function downfrom(i) {\n        if (isedge(h.mesh, i)) return -2;\n        var best = -1;\n        var besth = h[i];\n        var nbs = neighbours(h.mesh, i);\n        for (var j = 0; j < nbs.length; j++) {\n            if (h[nbs[j]] < besth) {\n                besth = h[nbs[j]];\n                best = nbs[j];\n            }\n        }\n        return best;\n    }\n    var downs = [];\n    for (var i = 0; i < h.length; i++) {\n        downs[i] = downfrom(i);\n    }\n    h.downhill = downs;\n    return downs;\n}\nexport function getFlux(h) {\n    var dh = downhill(h);\n    var idxs = [];\n    var flux = zero(h.mesh);\n    for (var i = 0; i < h.length; i++) {\n        idxs[i] = i;\n        flux[i] = 1/h.length;\n    }\n    idxs.sort(function (a, b) {\n        return h[b] - h[a];\n    });\n    for (var i = 0; i < h.length; i++) {\n        var j = idxs[i];\n        if (dh[j] >= 0) {\n            flux[dh[j]] += flux[j];\n        }\n    }\n    return flux;\n}\nexport function trislope(h, i) {\n    var nbs = neighbours(h.mesh, i);\n    if (nbs.length != 3) return [0, 0];\n    var p0 = h.mesh.vxs[nbs[0]];\n    var p1 = h.mesh.vxs[nbs[1]];\n    var p2 = h.mesh.vxs[nbs[2]];\n\n    var x1 = p1[0] - p0[0];\n    var x2 = p2[0] - p0[0];\n    var y1 = p1[1] - p0[1];\n    var y2 = p2[1] - p0[1];\n\n    var det = x1 * y2 - x2 * y1;\n    var h1 = h[nbs[1]] - h[nbs[0]];\n    var h2 = h[nbs[2]] - h[nbs[0]];\n\n    return [(y2 * h1 - y1 * h2) / det,\n        (-x2 * h1 + x1 * h2) / det];\n}\nfunction getSlope(h) {\n    var dh = downhill(h);\n    var slope = zero(h.mesh);\n    for (var i = 0; i < h.length; i++) {\n        var s = trislope(h, i);\n        slope[i] = Math.sqrt(s[0] * s[0] + s[1] * s[1]);\n    }\n    return slope;\n}\nexport function erosionRate(h) {\n    var flux = getFlux(h);\n    var slope = getSlope(h);\n    var newh = zero(h.mesh);\n    for (var i = 0; i < h.length; i++) {\n        var river = Math.sqrt(flux[i]) * slope[i];\n        var creep = slope[i] * slope[i];\n        var total = 1000 * river + creep;\n        total = total > 200 ? 200 : total;\n        newh[i] = total;\n    }\n    return newh;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/terrain/step4.js\n// module id = 3\n// module chunks = 0","import {isnearedge} from './step2';\nimport {downhill, getFlux} from './step4';\n\nexport function mergeSegments(segs) {\n    var adj = {};\n    for (var i = 0; i < segs.length; i++) {\n        var seg = segs[i];\n        var a0 = adj[seg[0]] || [];\n        var a1 = adj[seg[1]] || [];\n        a0.push(seg[1]);\n        a1.push(seg[0]);\n        adj[seg[0]] = a0;\n        adj[seg[1]] = a1;\n    }\n    var done = [];\n    var paths = [];\n    var path = null;\n    while (true) {\n        if (path == null) {\n            for (var i = 0; i < segs.length; i++) {\n                if (done[i]) continue;\n                done[i] = true;\n                path = [segs[i][0], segs[i][1]];\n                break;\n            }\n            if (path == null) break;\n        }\n        var changed = false;\n        for (var i = 0; i < segs.length; i++) {\n            if (done[i]) continue;\n            if (adj[path[0]].length == 2 && segs[i][0] == path[0]) {\n                path.unshift(segs[i][1]);\n            } else if (adj[path[0]].length == 2 && segs[i][1] == path[0]) {\n                path.unshift(segs[i][0]);\n            } else if (adj[path[path.length - 1]].length == 2 && segs[i][0] == path[path.length - 1]) {\n                path.push(segs[i][1]);\n            } else if (adj[path[path.length - 1]].length == 2 && segs[i][1] == path[path.length - 1]) {\n                path.push(segs[i][0]);\n            } else {\n                continue;\n            }\n            done[i] = true;\n            changed = true;\n            break;\n        }\n        if (!changed) {\n            paths.push(path);\n            path = null;\n        }\n    }\n    return paths;\n}\n\nfunction relaxPath(path) {\n    var newpath = [path[0]];\n    for (var i = 1; i < path.length - 1; i++) {\n        var newpt = [0.25 * path[i-1][0] + 0.5 * path[i][0] + 0.25 * path[i+1][0],\n            0.25 * path[i-1][1] + 0.5 * path[i][1] + 0.25 * path[i+1][1]];\n        newpath.push(newpt);\n    }\n    newpath.push(path[path.length - 1]);\n    return newpath;\n}\nexport function getRivers(h, limit) {\n    var dh = downhill(h);\n    var flux = getFlux(h);\n    var links = [];\n    var above = 0;\n    for (var i = 0; i < h.length; i++) {\n        if (h[i] > 0) above++;\n    }\n    limit *= above / h.length;\n    for (var i = 0; i < dh.length; i++) {\n        if (isnearedge(h.mesh, i)) continue;\n        if (flux[i] > limit && h[i] > 0 && dh[i] >= 0) {\n            var up = h.mesh.vxs[i];\n            var down = h.mesh.vxs[dh[i]];\n            if (h[dh[i]] > 0) {\n                links.push([up, down]);\n            } else {\n                links.push([up, [(up[0] + down[0])/2, (up[1] + down[1])/2]]);\n            }\n        }\n    }\n    return mergeSegments(links).map(relaxPath);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/terrain/step6.js\n// module id = 4\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"d3-array\"\n// module id = 5\n// module chunks = 0","import seedrandom from 'seedrandom/seedrandom';\nimport {defaultExtent} from './step1';\nimport {generateCoast, doErosion, cleanCoast} from './step5';\nimport {getRivers} from './step6';\nimport {contour} from './step7';\nimport {setSeaLevel, fillSinks} from './step3';\n\nfunction seed(seedString, isUsingSeed){\n    seedrandom(seedString, {\n        global: isUsingSeed\n    });\n}\n\nexport function generateMap(n, seedString, isUsingSeed){\n    n = n || Math.pow(2, 10);\n    seedString = seedString || 'map';\n   seed(seedString, isUsingSeed);\n\n   var points = generateCoast({npts: n, extent: defaultExtent});\n   return {\n       points: points,\n       coast: contour(points, 0),\n       rivers: getRivers(points, 0.03),\n       mesh: points.mesh\n   };\n}\n\nfunction setDefault(value, defaultValue){\n    if(value === undefined || value === null){\n        return defaultValue;\n    }\n    else{\n        return value;\n    }\n}\n\nexport function erodeMap(originalPoints, erosionRate, seaRate, coastRate){\n    erosionRate = setDefault(erosionRate, 0.1);\n    seaRate = setDefault(seaRate, 0.5);\n    coastRate = setDefault(coastRate, 1);\n\n    var points = doErosion(originalPoints, erosionRate);\n    points= setSeaLevel(points, seaRate);\n    points= cleanCoast(points, coastRate);\n    points= fillSinks(points);\n\n    var coast = contour(points, 0);\n    var rivers = getRivers(points, 0.01);\n    return {\n        points: points,\n        coast: coast,\n        rivers: rivers,\n        mesh: points.mesh\n    };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/terrain/terrain.js\n// module id = 6\n// module chunks = 0","import {zero, generateGoodMesh, add, slope, randomVector, runif} from './step2';\nimport {neighbours, cone, mountains, peaky, setSeaLevel, fillSinks} from './step3';\nimport {erosionRate} from './step4';\nimport {mean, max} from 'd3-array';\n\nexport function cleanCoast(h, iters) {\n    for (var iter = 0; iter < iters; iter++) {\n        var changed = 0;\n        var newh = zero(h.mesh);\n        for (var i = 0; i < h.length; i++) {\n            newh[i] = h[i];\n            var nbs = neighbours(h.mesh, i);\n            if (h[i] <= 0 || nbs.length != 3) continue;\n            var count = 0;\n            var best = -999999;\n            for (var j = 0; j < nbs.length; j++) {\n                if (h[nbs[j]] > 0) {\n                    count++;\n                } else if (h[nbs[j]] > best) {\n                    best = h[nbs[j]];\n                }\n            }\n            if (count > 1) continue;\n            newh[i] = best / 2;\n            changed++;\n        }\n        h = newh;\n        newh = zero(h.mesh);\n        for (var i = 0; i < h.length; i++) {\n            newh[i] = h[i];\n            var nbs = neighbours(h.mesh, i);\n            if (h[i] > 0 || nbs.length != 3) continue;\n            var count = 0;\n            var best = 999999;\n            for (var j = 0; j < nbs.length; j++) {\n                if (h[nbs[j]] <= 0) {\n                    count++;\n                } else if (h[nbs[j]] < best) {\n                    best = h[nbs[j]];\n                }\n            }\n            if (count > 1) continue;\n            newh[i] = best / 2;\n            changed++;\n        }\n        h = newh;\n    }\n    return h;\n}\nfunction relax(h) {\n    var newh = zero(h.mesh);\n    var innerFunction = function (j) {return h[j]};\n    for (var i = 0; i < h.length; i++) {\n        var nbs = neighbours(h.mesh, i);\n        if (nbs.length < 3) {\n            newh[i] = 0;\n            continue;\n        }\n        newh[i] = mean(nbs.map(innerFunction));\n    }\n    return newh;\n}\nfunction erode(h, amount) {\n    var er = erosionRate(h);\n    var newh = zero(h.mesh);\n    var maxr = max(er);\n    for (var i = 0; i < h.length; i++) {\n        newh[i] = h[i] - amount * (er[i] / maxr);\n    }\n    return newh;\n}\nexport function doErosion(h, amount, n) {\n    n = n || 1;\n    h = fillSinks(h);\n    for (var i = 0; i < n; i++) {\n        h = erode(h, amount);\n        h = fillSinks(h);\n    }\n    return h;\n}\nexport function generateCoast(params) {\n    var mesh = generateGoodMesh(params.npts, params.extent);\n    var h = add(\n        slope(mesh, randomVector(4)),\n        cone(mesh, runif(-1, -1)),\n        mountains(mesh, 50)\n    );\n    for (var i = 0; i < 10; i++) {\n        h = relax(h);\n    }\n    h = peaky(h);\n    h = doErosion(h, runif(0, 0.1), 5);\n    h = setSeaLevel(h, runif(0.2, 0.6));\n    h = fillSinks(h);\n    h = cleanCoast(h, 3);\n    return h;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/terrain/step5.js\n// module id = 7\n// module chunks = 0","import {isnearedge} from './step2';\nimport {mergeSegments} from './step6';\n\nexport function contour(h, level) {\n    level = level || 0;\n    var edges = [];\n    for (var i = 0; i < h.mesh.edges.length; i++) {\n        var e = h.mesh.edges[i];\n        if (e[3] == undefined) continue;\n        if (isnearedge(h.mesh, e[0]) || isnearedge(h.mesh, e[1])) continue;\n        if ((h[e[0]] > level && h[e[1]] <= level) ||\n            (h[e[1]] > level && h[e[0]] <= level)) {\n            edges.push([e[2], e[3]]);\n        }\n    }\n    return mergeSegments(edges);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/terrain/step7.js\n// module id = 8\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_9__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"d3-voronoi\"\n// module id = 9\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_10__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"seedrandom\"\n// module id = 10\n// module chunks = 0"],"sourceRoot":""}